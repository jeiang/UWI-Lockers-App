package main

import (
	"context"
	"embed"
	"fmt"
	"io/fs"
	"net/http"
	"os"
	"sync"
	"time"

	"github.com/charmbracelet/log"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/patrickmn/go-cache"

	"aidanpinard.co/lockers-app/handlers"
	"aidanpinard.co/lockers-app/middleware"
	"github.com/gorilla/mux"
)

const (
	SPA_ROOT = "frontend/dist"
	INDEX    = "index.html"
)

//go:embed all:frontend/dist
var preactFS embed.FS

// Keep the main thread from dying until server processes are done
var wg sync.WaitGroup

func main() {
	// setup cache path flag
	config := loadConfig()

	// set up db
	db, err := pgxpool.New(context.Background(), os.Getenv("DATABASE_URL"))
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	tokenBlacklistCache := cache.New(handlers.Expiration, handlers.Expiration)

	// Root at the `dist` folder generated by the preact app.
	distFS, err := fs.Sub(preactFS, SPA_ROOT)
	if err != nil {
		log.Fatal(err)
	}

	r := mux.NewRouter().StrictSlash(true)
	r.Use(middleware.Log)
	s := r.PathPrefix("/api/v1").Subrouter()
	s.Path("/").Methods(http.MethodGet).HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "Hello, world!")
	})
	// TODO: add logout endpoint with expiration
	s.Path("/login").Methods(http.MethodPost).Handler(&handlers.LoginHandler{
		DB: db,
	})
	s.Path("/secret").Handler(middleware.AuthMW(tokenBlacklistCache, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "you were authenticated!!!")
	})))
	// The static preact app will be served under `/`.
	r.PathPrefix("/").Handler(&handlers.FileServerWithFallback{
		HttpFileServer: http.FS(distFS),
		Fallback:       INDEX,
	})

	server := &http.Server{
		Handler:      r,
		Addr:         config.addr,
		WriteTimeout: 15 * time.Second,
	}

	// TODO: tls
	wg.Add(1)
	go func() {
		defer wg.Done()
		log.Infof("starting server on http://%s", config.addr)
		err := server.ListenAndServe()
		if err != nil {
			log.Fatal(err)
		}
	}()

	wg.Wait()
}
